function N(){}function Y(n,t){for(const e in t)n[e]=t[e];return n}function O(n){return n()}function C(){return Object.create(null)}function $(n){n.forEach(O)}function B(n){return typeof n=="function"}function Z(n,t){return n!=n?t==t:n!==t||n&&typeof n=="object"||typeof n=="function"}function I(n){return Object.keys(n).length===0}let b=!1;function L(){b=!0}function z(){b=!1}function D(n,t,e,r){for(;n<t;){const c=n+(t-n>>1);e(c)<=r?n=c+1:t=c}return n}function F(n){if(n.hydrate_init)return;n.hydrate_init=!0;let t=n.childNodes;if(n.nodeName==="HEAD"){const i=[];for(let o=0;o<t.length;o++){const a=t[o];a.claim_order!==void 0&&i.push(a)}t=i}const e=new Int32Array(t.length+1),r=new Int32Array(t.length);e[0]=-1;let c=0;for(let i=0;i<t.length;i++){const o=t[i].claim_order,a=(c>0&&t[e[c]].claim_order<=o?c+1:D(1,c,g=>t[e[g]].claim_order,o))-1;r[i]=e[a]+1;const l=a+1;e[l]=i,c=Math.max(l,c)}const s=[],u=[];let f=t.length-1;for(let i=e[c]+1;i!=0;i=r[i-1]){for(s.push(t[i-1]);f>=i;f--)u.push(t[f]);f--}for(;f>=0;f--)u.push(t[f]);s.reverse(),u.sort((i,o)=>i.claim_order-o.claim_order);for(let i=0,o=0;i<u.length;i++){for(;o<s.length&&u[i].claim_order>=s[o].claim_order;)o++;const a=o<s.length?s[o]:null;n.insertBefore(u[i],a)}}function H(n,t){if(b){for(F(n),(n.actual_end_child===void 0||n.actual_end_child!==null&&n.actual_end_child.parentNode!==n)&&(n.actual_end_child=n.firstChild);n.actual_end_child!==null&&n.actual_end_child.claim_order===void 0;)n.actual_end_child=n.actual_end_child.nextSibling;t!==n.actual_end_child?(t.claim_order!==void 0||t.parentNode!==n)&&n.insertBefore(t,n.actual_end_child):n.actual_end_child=t.nextSibling}else(t.parentNode!==n||t.nextSibling!==null)&&n.appendChild(t)}function nn(n,t,e){b&&!e?H(n,t):(t.parentNode!==n||t.nextSibling!=e)&&n.insertBefore(t,e||null)}function P(n){n.parentNode&&n.parentNode.removeChild(n)}function T(n){return document.createTextNode(n)}function tn(){return T("")}function G(n){return Array.from(n.childNodes)}function en(n,t){return new n(t)}let y;function m(n){y=n}function j(){if(!y)throw new Error("Function called outside component initialization");return y}function on(n){j().$$.on_mount.push(n)}function rn(n,t){return j().$$.context.set(n,t),t}function cn(n){return j().$$.context.get(n)}const h=[],A=[];let p=[];const M=[],J=Promise.resolve();let k=!1;function K(){k||(k=!0,J.then(q))}function E(n){p.push(n)}const w=new Set;let _=0;function q(){if(_!==0)return;const n=y;do{try{for(;_<h.length;){const t=h[_];_++,m(t),Q(t.$$)}}catch(t){throw h.length=0,_=0,t}for(m(null),h.length=0,_=0;A.length;)A.pop()();for(let t=0;t<p.length;t+=1){const e=p[t];w.has(e)||(w.add(e),e())}p.length=0}while(h.length);for(;M.length;)M.pop()();k=!1,w.clear(),m(n)}function Q(n){if(n.fragment!==null){n.update(),$(n.before_update);const t=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,t),n.after_update.forEach(E)}}function R(n){const t=[],e=[];p.forEach(r=>n.indexOf(r)===-1?t.push(r):e.push(r)),e.forEach(r=>r()),p=t}const x=new Set;let d;function un(){d={r:0,c:[],p:d}}function sn(){d.r||$(d.c),d=d.p}function U(n,t){n&&n.i&&(x.delete(n),n.i(t))}function fn(n,t,e,r){if(n&&n.o){if(x.has(n))return;x.add(n),d.c.push(()=>{x.delete(n),r&&(e&&n.d(1),r())}),n.o(t)}else r&&r()}function ln(n,t){const e={},r={},c={$$scope:1};let s=n.length;for(;s--;){const u=n[s],f=t[s];if(f){for(const i in u)i in f||(r[i]=1);for(const i in f)c[i]||(e[i]=f[i],c[i]=1);n[s]=f}else for(const i in u)c[i]=1}for(const u in r)u in e||(e[u]=void 0);return e}function an(n){return typeof n=="object"&&n!==null?n:{}}function dn(n){n&&n.c()}function _n(n,t){n&&n.l(t)}function V(n,t,e,r){const{fragment:c,after_update:s}=n.$$;c&&c.m(t,e),r||E(()=>{const u=n.$$.on_mount.map(O).filter(B);n.$$.on_destroy?n.$$.on_destroy.push(...u):$(u),n.$$.on_mount=[]}),s.forEach(E)}function W(n,t){const e=n.$$;e.fragment!==null&&(R(e.after_update),$(e.on_destroy),e.fragment&&e.fragment.d(t),e.on_destroy=e.fragment=null,e.ctx=[])}function X(n,t){n.$$.dirty[0]===-1&&(h.push(n),K(),n.$$.dirty.fill(0)),n.$$.dirty[t/31|0]|=1<<t%31}function hn(n,t,e,r,c,s,u,f=[-1]){const i=y;m(n);const o=n.$$={fragment:null,ctx:[],props:s,update:N,not_equal:c,bound:C(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(i?i.$$.context:[])),callbacks:C(),dirty:f,skip_bound:!1,root:t.target||i.$$.root};u&&u(o.root);let a=!1;if(o.ctx=e?e(n,t.props||{},(l,g,...S)=>{const v=S.length?S[0]:g;return o.ctx&&c(o.ctx[l],o.ctx[l]=v)&&(!o.skip_bound&&o.bound[l]&&o.bound[l](v),a&&X(n,l)),g}):[],o.update(),a=!0,$(o.before_update),o.fragment=r?r(o.ctx):!1,t.target){if(t.hydrate){L();const l=G(t.target);o.fragment&&o.fragment.l(l),l.forEach(P)}else o.fragment&&o.fragment.c();t.intro&&U(n.$$.fragment),V(n,t.target,t.anchor,t.customElement),z(),q()}m(i)}class pn{$destroy(){W(this,1),this.$destroy=N}$on(t,e){if(!B(e))return N;const r=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return r.push(e),()=>{const c=r.indexOf(e);c!==-1&&r.splice(c,1)}}$set(t){this.$$set&&!I(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}export{pn as S,Z as a,nn as b,sn as c,U as d,tn as e,P as f,cn as g,un as h,hn as i,A as j,en as k,dn as l,_n as m,V as n,on as o,ln as p,an as q,W as r,rn as s,fn as t,Y as u};
